js 与 nodejs 区别与联系
js = ecma + bom + dom  即 ECMASCRIPT 基础的语法和对象 + 浏览器操作对象 + 文档操作对象
nodejs  = ecma + fs + os + net + database... 即在 ECMASCRIPT 基础上 扩展了 操作非浏览器的方法和对象
结论: 
1. js 与 nodejs 在底层是一样的(比如与数据类型的定义、语法结构，内置对象),但扩展出的东西却不一样,所以 js偏向前端, nodejs 偏向后端
1. 还有就是 js顶层对象是 window 而 nodejs 却是 global
1. nodejs 依赖 v8 引擎 , js 依赖浏览器


高并发: nodejs 异步机制, 不会阻塞新连接的用户, 新连接的用户会进入事件队列, 但维护队列也会让nodejs 进入瓶颈;;其它如java,php 会给新连接用户直接分配新的os线程和配套内存, 这样会直接影响其并发机制.
:: Java、PHP也有办法实现并行请求（子线程），但NodeJS通过回调函数（Callback）和异步机制会做得很自然。


I/O密集型():nodejs 是单进程和单线程的, 但遇到I/O事件会创建一个线程去执行,这就是NodeJS非阻塞I/O的特点

不适合CPU密集型应用, 只支持单核CPU，不能充分利用CPU, 多了浪费, 因为nodejs 只能用一个
解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；（2）开多个进程监听同一个端口，使用cluster模块；




Object.defineProperty(obj, prop, descriptor)：当属性的 configurable 为 true 时，可以对已有的属性的描述符进行变更。
Object.preventExtensions(obj)：阻止 obj 被添加新的属性。
Object.seal(obj)：阻止 obj 被添加新的属性或者删除已有的属性。
Object.freeze(obj)：阻止 obj 被添加新的属性、删除已有的属性或者更新已有的属性。


Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));


 Reflect.ownKeys（obj）= Object.getOwnPropertyNames（target）+ 
 Object.getOwnPropertySymbols（target)

  //不打印myMethod，因为它被定义为不可枚举
 console.log（Object.keys（testObject））; 

 //打印myMethod，不管它是否可枚举。 
 console.log（Reflect.ownKeys（testObject））; 


### js中匿名函数 的 全局性
```
var obj = {
      eat: function () {
        console.log('eat', this) // obj
        return (function () {
          console.log('eat in', this) // window
          return 1;
        })()
      },
      test: function () {
        console.log('test', this) //obj
        return function () {
          console.log('test in', this) //window
        }
      }
    }
this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this指向的是window；当函数被作为某个对象的方法调用时，this就等于那个对象

箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。

知识点:
执行(运行)时绑定 - 执行时还在对象
定义时绑定- 定义时所在的对象
```

### 简易版 Promise
```
function TPromise(cb) {
  this._success = [];
  this._error = [];

  setTimeout(() => { // 防止立即执行,推入 事件队列
    cb && cb(this.rev.bind(this), this.rej.bind(this)) // 传入函数时, 绑定this指向
  }, 0)
  return this;
}

TPromise.prototype = {
  constructor: TPromise,
  rev: function (val) {
    let r = this._success.shift();
    let ret = r && r(val)
    if (ret instanceof TPromise) {
      this._success.forEach(fn => {
        ret.then(fn)
      });
      this._success.length = 0;
    } else {
      ret && this.rev(ret)
    }
  },
  rej: function (val) {
    let r = this._error.shift();
    r && r(this.rev, this.rej)
  }
}

TPromise.prototype.then = function (rev, reject) {
  rev && this._success.push(rev)
  reject && this._error.push(reject)
  return this;
}

TPromise.prototype.catch = function (rev, reject) {
  return this;
}
```


 ####
 ```
 2.浏览器线程

js运作在浏览器中,是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。
浏览器是多线程的，除了js引擎线程，它还有： 
UI渲染线程
浏览器事件触发线程
http请求线程
EventLoop轮询的处理线程
……..


这些线程的作用：


UI线程用于渲染页面
js线程用于执行js任务
浏览器事件触发线程用于控制交互，响应用户
http线程用于处理请求，ajax是委托给浏览器新开一个http线程
EventLoop处理线程用于轮询消息队列


 ```

 #### [](https://www.cnblogs.com/mafeng/p/6292534.html) [](https://segmentfault.com/a/1190000012925872)
 ```
 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）
 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。


 js单线程


单线程的含义是js只能在一个线程上运行，也就说，js同时只能执行一个js任务，其它的任务则会排队等待执行。
js是单线程的,并不代表js引擎线程只有一个。js引擎有多个线程，一个主线程，其它的后台配合主线程。
多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦。js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。这也就解释了js执行时会阻塞页面的渲染。




4.消息队列(任务队列)


JavaScript运行时，除了一个运行线程，引擎还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列的时候，会自动排在队列的尾端。  



消息和回调函数相互联系；

  单线程意味着js任务需要排队，如果前一个任务出现大量的耗时操作，后面的任务得不到执行，任务的积累会导致页面的“假死”。这也是js编程一直在强调需要回避的“坑”。



5.js任务

任务分为2种:  


同步任务  
异步任务  


它们的区别是: 本段中的线程指的是js引擎主线程


同步任务：在主线程排队支持的任务，前一个任务执行完毕后，执行后一个任务,形成一个执行栈，线程执行时在内存形成的空间为栈，进程形成堆结构，这是内存的结构。执行栈可以实现函数的层层调用。注意不要理解成同步代码进入栈中，按栈的出栈顺序来执行。
异步任务会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会。


主线程执行的说明: 【js的运行机制】 


  （1）所有同步任务都在主线程上执行，形成一个执行栈。 
  （2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 
  （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 
  （4）主线程不断重复上面的第三步。    


执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。

浏览器中的JS是单线程的。
setInterval和setTimeout并不是多线程，这两个函数根本上其实是事件触发函数
setTimeout，setInterval并不是多线程，只是一个定时的事件触发器，它们在合适的时间把一些JS代码塞到JS引擎的队列中。
setTimeout(aFunction, 0)，这行代码看似的意思是在0秒之后执行aFunction, 但这并不意味着立即执行。其它真正的意思是立刻把aFunction的代码放到当前JS引擎的队列中。所以当前代码块执行完成之前，aFunction的代码是得不到执行的。比如这段代码，一定是world先出来，hello后出来。尽管setTimeout的参数是0，但这并不意味着立即执行
setTimeout(function() {  
    alert("hello");  
}, 0)  
alert("world")  


浏览器中有三个常驻的线程，分别是JS引擎，界面渲染，事件响应。由于这三个线程同时要访问DOM树，所以为了线程安全，浏览器内部需要做互斥：当JS引擎在执行代码的时候，界面渲染和事件响应两个线程是被暂停的。所以当JS出现死循环，浏览器无法响应点击，也无法更新界面。现在的浏览器的JS引擎都是单线程的，尽管多线程功能强大，但是线程同步比较复杂，并且危险，稍有不慎就会崩溃死锁。单线程的好处不必考虑线程同步这样的复杂问题，
 ```

 ```
 这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流：

如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。
如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。
而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。
 ```

### Date ios 
```
时间，而在iOS上缺不能正常显示，显示的时间为：NaN-NaN1-NaN ，例如：

new Date('2017-09-18 14:58:32').getTime();      //在ios上拿不到时间戳显示NaN


在网上找问题出现原因，看到以下内容：

在IOS5以上版本（不包含IOS5）中的Safari浏览器能正确解释出Javascript中的 new Date('2013-10-21') 的日期对象。
但是在IOS5版本里面的Safari解释new Date('2013-10-21') 就不正确，在IOS5的Safari中返回的永远是"Invalid Date"。
后来我在网上查找了资料，原来是低版本的Safari解释new Date('2013-10-21')这个对象不一样，在IOS5中的Safari不支持这种写法，而它支持的写法为new Date('2013','10','21'),这样写就能解决"Invalid Date"的问题，能返回一个Javascript Date回来了。
但是随之而来的问题有出现了，Date是返回过来了，可是这个Date对象中方法返回的数据可不是我想要的，返回的数据全都不正确。
现在返回过来的Date对象.getMonth()总要比正常的要多一个月！还有.getDay()返回的星期几也不正确！

所以想要正确显示时间在iOS上，应该这么写

new Date("2018-02-15 20:30:00".replace(/-/g,'/')).getTime();  // 解决了问题！！
```

# js为什么需要模块化开发

2017年11月27日 13:12:02 [m_review](https://me.csdn.net/m_review) 阅读数：3502



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/m_review/article/details/78643967

# 何为模块化开发与按需加载

## 何为模块化开发？

为了回答这个问题，首先解释何为“模块”：

“模块”是为完成某一功能所需的一段程序或子程序。模块是系统中“职责单一”且“可替换”的部分。

所谓的模块化就是指把系统代码分为一系列职责单一且可替换的模块。模块化开发是指如何开发新的模块和复用已有的模块来实现应用的功能。

## 何为按需加载

按需加载需要从时间和空间两方面理解。

空间上：只加载当前页面的模块

时间上：只有当用户表现出需要某一功能的意图时，才去加载相关模块。

## 模块化开发与按需加载的适用场景

满足如下条件的应用适合采用模块化开发与按需加载技术：

- 应用复杂。不止一个功能部分，这些部分可能共享一些底层代码
- 需要长期维护。开发初期可能需求不太明确，需要不断迭代开发，经常面临需求变更和功能添加。
- 对性能要求苛刻。面临复杂的yoghurt交互和数据展现问题。

## 传统的js开发模式和加载模式是怎么样的？

在过去由于应用的复杂度不高，js之于web页面一直处于一种辅助程序的地位，甚至谈不上一门应用开发语言。而且多数网站都是一次性应用，规模较小，相对于可维护性，开发速度更重要。与其重构一个现有应用，还不如重写一个，在这样的环境下，采用传统的面向过程的编程模式足以应付开发需要。

由于网站规模小，与其把代码划分为小的模块，然后在不同的页面分别加载，还不如把相关的代码都集中写在一个处，比如写一个common.js或share.js，然后所有的页面都引用这个文件。这样做开发简单，而且由于浏览器有缓存，首次加载后，后续无需网络传输，性能上不会有什么太大的问题。

## 传统开发模式的问题。

- 问题一：由于代码的组织的结构是非模块化的，所以代码无法复用，进而导致代码重复，这就为维护埋下了隐患 – 需求变更或功能添加将导致代码多处更改，随着应用规模的增大，代码将迅速进入难以维护的状态。
- 问题二：由于代码粒度太大，页面可能会加载大量根本用不到的代码，即便忽略网络传输的问题，过多无用代码，也会导致页面解析缓慢。
- 问题三：由于所有代码都混在一起，无法测试，我们也就无法获得保证代码质量的有效手段。

## 为什么需要模块化开发与按需加载

### 可维护性的需要

代码的可维护性的一种理解是，新功能的添加无需修改已有代码，旧有功能的变更无需修改多处代码。

对于初期需求不明确，需要采用不断迭代方式开发的项目，代码可维护性就显的尤为重要。

### 可测性的需要

代码的可测性的一种理解是，代码可以在系统环境外进行独立正确性验证。在系统环境外对代码进行测试十分重要，这不仅能保证代码的正确性，同时也保证了代码可以在不同环境中复用。

### 性能的需要

模块化的代码可以实现按需加载，进而保证了我们不会把宝贵的页面加载时间浪费在下载和解释多余的代码上。

### 架构的需求

架构的任务之一是保证系统可以应对未来的变化。这些变化包括新功能的添加，原有功能的修改，地层库文件的更换（有jQuery切换到tangram或其他），性能优化等等。任何可以实现这一目标的架构都要求代码必须是模块化的。

### 代码复用

代码复用不仅仅是为了节省开发时间，同时也是保证代码质量的有效手段，代码的复用程度越高，其质量就越容易得到保证。

### 多人协作的需要。

大型应用无法通过一人之力完成，多人协作是不可避免的。在多人协作的环境下，经常要面临修改或使用别人写的代码的问题。只有那些功能单一，接口明确，模块化代码我们才敢放心大胆的修改或使用。

## 模块化开发的理论基础

模块化开发是任何大型应用都必须采用的开发模式，同其他应用程序的开发一样，要实现js模块化开发，我们需要了解下面理论基础。

- 面向对象 
  相对于面向过程式的编程模式，面向对象倡导的是以更符合现实世界的认知模式去构建我们的程序，而不是从计算机的角度去理解问题模型。其核心思想是“封装”，“继承”，“多态”。对于js模块化开发，“封装”的思想最为重要。“封装”是指把不应该暴露给其他代码的逻辑，方法或属性隐藏在对象（模块）内部。对外只提供必要的接口。进而保证了代码的高内聚与低耦合。JavaScript不是一门纯粹的面向对象语言，它融合了面向过程，面向对象，函数式程序设计语言的思想，这也导致了这门语言的复杂性。为了更好的理解JavaScript面向对象编程思想推荐阅读以下两本书：

  《JavaScript语言精粹》 《object oriented javaScript》

- 设计模式 
  设计模式要解决的问题是如何组织和协调不同对象去解决程序问题。完整介绍设计模式不是本文职责所在，这里只举几个简单的例子。

  - 单例模式。单例模式是指在程序运行期间保证一个类只有一个实例。由于JavaScript没有类的概念，应用单例模式其实就是保证我们的程序在运行期间，某一功能对象一直只是同一个对象，而不是每次都重复创建。
  - 订阅者模式。这是JavaScript中应用最为广泛的模式。我们通过addEventListener或attachEvent为dom节点添加事件监听，其实就是在应用订阅者模式。订阅者模式通过让一组对象去监听一个对象的事件，实现对象间一对多的通信，在最大程度上降低了对象间的耦合度。
  - 外观模式。外观模式通过将一个或一组对象的接口封装起来，对外只提供其他代码需要的接口，实现降低代码耦合度的任务。

## 如何实践

- CommonJS。JavaScript没有内建的模块支持，而CommonJS规范给出了完整的JavaScript实现模块的方式。
- 前端支持。有大量成熟的js按需加载框架可以使用，这里推荐seajs。详细内容见“参考资料”。
- 后端支持。模块化的代码上线前需要进行打包压缩，打包过程需要通过对源码进行静态分析来获得模块间的依赖关系，进而将相关模块打包在一起。Seajs提供的spm工具可以自动完成这一个工作。