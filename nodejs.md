
# NodeJS


### NodeJS 安装
```
1、下载并安装最新版本的 node  

    node -v查看版本号
    node 多版本管理：nvm 管理window, n 管理 linux

2、常见模块：

    http: createServer(callback(req, res).listen(端口);
    fs: readFileSync、readFile
    events: EventEmitter
    url: parse
    querystring: parse
    os:
    path:
```

### NodeJS 优缺点
```
优点：
1. 高并发（最重要的优点）

2. 适合I/O密集型应用(异步)

缺点：
1. 不适合CPU密集型应用（同步，阻塞）；
    CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

2. 只支持单核CPU，不能充分利用CPU

3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

原因：单进程，单线程

解决方案：
（1）Nginx反向代理，负载均衡，开多个进程，绑定多个端口；

（2）开多个进程监听同一个端口，使用cluster模块；

4. 开源组件库质量参差不齐，更新快，向下不兼容

5. Debug不方便，错误没有stack trace
```


#### NodeJS 支持 高并发、非阻塞 原理
```
其实Nodejs对外展示是单线程的，但内部其实是多线程的，Node本身的主线程主要就是起不断往返调度的作用

Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。

NodeJS 单线程 = 业务处理（cpu的运算）主线程 + 异步I/O 线程等（工作线程）
主线程：在JS引擎中负责解释和执行Javascript代码的线程只有一个
工作线程 = 处理AJAX请求的线程 + 处理DOM事件的线程 + 定时器线程 + 读写文件的线程

因为I/O操作是由node的工作线程去执行的（nodejs底层的libuv是多线程的线程池用来并行io操作），且主线程是不需要等待结果返回的，只要发出指令马上就可以去忙其他事情了。

NodeJS 高并发 = 异步I/O + 事件驱动（回调函数）

多线程模型：
单线程模型：

线程驱动：当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。一般存在一个线程池，线程池中有空闲的线程，会从线程池中拿取线程来进行处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程。
事件驱动：当进来一个新的请求的时，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。

事件驱动模型：node 进程启动时，创建 类似 white(true) ，循环取出消息队列(event-queue)中的消息进行处理,处理过程基本上就是去调用该消息对应的回调函数
```

#### NodeJS 适合场景
```
1、RESTful API

这是适合 Node 的理想情况，因为您可以构建它来处理数万条连接。它仍然不需要大量逻辑；它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。

2、实时程序

比如聊天服务

聊天应用程序是最能体现 Node.js 优点的例子：轻量级、高流量并且能良好的应对跨平台设备上运行密集型数据（虽然计算能力低）。同时，聊天也是一个非常值得学习的用例，因为它很简单，并且涵盖了目前为止一个典型的 Node.js 会用到的大部分解决方案。

3、单页APP

ajax很多。现在单页的机制似乎很流行，比如phonegap做出来的APP，一个页面包打天下的例子比比皆是。

总而言之，NodeJS适合运用在高并发、I/O密集(频繁 API请求)、少量业务逻辑的场景
```


#### 压力测试
```
安装 siege

```

#### JS 网络模块
```
node提供了net、dgram、http、https 4个模块，
    分别用于处理TCP、UDP、HTTP、HTTPS
```

#### JS [多线程模块](https://blog.csdn.net/zwjabcd/article/details/50393810)
```
TAGG:node-threads-a-gogo
webworker-threads(TAGG):利用 CUP 多核
多核处理模块cluster
nodejs + nginx + redis cluster 高并发解决方案
PM2模块是cluster模块的一个包装层。它的作用是尽量将cluster模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。

由于webworker-threads是在TAGG的基础上实现的，因此也可以不使用Web Worker，而直接创建线程对象Thread或线程池ThreadPool来实现多线程编程。

[用cluster实现负载均衡(Load Balance) ](https://www.cnblogs.com/duhuo/p/4767954.html)
```

##### 多进程单线程模型与单进程多线程模型之争

多进程单线程模型典型代表：**nginx**(redis\mongodb)
单进程多线程模型典型代表：**memcached**

##### 单进程多线程肯定比多进程单线程快一些

这是因为 进程间的切换消耗更大一些,  但是，没有你想象的“快几倍”

##### 单进程多线程肯定有其不利的一面

在代码上非常容易出错,守护程序”来重启，但是重启期间，你的服务器是真的“挂掉了”.

##### 如果你真的想要密集处理，请使用C/C++

在 Node.js 中处理 CPU 密集型计算一般有三种方案：

写独立的 c 代码
使用 Node.js 自带的 让node支持多进程模型的模块  cluster 模块(推荐)
使用其他开源项目，如 让node支持多线程模型的模块 threads-a-gogo：安装 npm install tagg2

常做的通用功能模块封装：

遍历文件或目录

单个文件或目录的读写

处理各种请求

数据库所有操作
